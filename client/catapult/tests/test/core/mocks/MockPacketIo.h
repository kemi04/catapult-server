#pragma once
#include "catapult/ionet/PacketIo.h"
#include <queue>
#include <vector>

namespace catapult { namespace mocks {

	/// A mock PacketIo that can be configured to pass specific values to read and write callbacks.
	class MockPacketIo : public ionet::PacketIo {
	public:
		/// Generates a read packet from the previously written packet or \c nullptr if no packets have been read.
		using GenerateReadPacket = std::function<std::shared_ptr<ionet::Packet> (const ionet::Packet*)>;

	public:
		/// Creates a new mock packet io.
		MockPacketIo() : m_numReads(0), m_numWrites(0)
		{}

	public:
		void read(const ReadCallback& callback) override {
			++m_numReads;

			auto pair = m_queuedReads.front();
			m_queuedReads.pop();

			auto pPacket = invoke(pair.second);
			callback(pair.first, pPacket.get());
		}

		void write(const ionet::PacketPayload& payload, const WriteCallback& callback) override {
			++m_numWrites;

			auto code = m_queuedWrites.front();
			m_queuedWrites.pop();

			m_writtenPackets.push_back(PayloadToPacket(payload));
			callback(code);
		}

	public:
		/// Returns the number of reads on this io.
		size_t numReads() const { return m_numReads; }

		/// Returns the number of writes on this io.
		size_t numWrites() const { return m_numWrites; }

		/// Returns a reference to the written packet at index \a index.
		template<typename T>
		const T& writtenPacketAt(size_t index) const {
			return static_cast<const T&>(*m_writtenPackets[index]);
		}

	public:
		/// Queues a read operation to return \a code and a \c nullptr packet.
		void queueRead(const ionet::SocketOperationCode& code) {
			queueRead(code, GenerateReadPacket());
		}

		/// Queues a read operation to return \a code and a packet generated by \a generate.
		void queueRead(const ionet::SocketOperationCode& code, const GenerateReadPacket& generate) {
			m_queuedReads.emplace(code, generate);
		}

		/// Queues a write operation to return \a code.
		void queueWrite(const ionet::SocketOperationCode& code) {
			m_queuedWrites.push(code);
		}

	private:
		std::shared_ptr<ionet::Packet> invoke(const GenerateReadPacket& generate) const {
			if (!generate) return nullptr;

			return generate(m_writtenPackets.empty() ? nullptr : m_writtenPackets.back().get());
		}

	private:
		static std::shared_ptr<ionet::Packet> PayloadToPacket(const ionet::PacketPayload& payload) {
			const auto& header = payload.header();
			auto pPacket = ionet::CreateSharedPacket<ionet::Packet>(header.Size - sizeof(ionet::Packet));
			pPacket->Type = header.Type;

			size_t dataOffset = 0;
			for (const auto& buffer : payload.buffers()) {
				std::memcpy(pPacket->Data() + dataOffset, buffer.pData, buffer.Size);
				dataOffset += buffer.Size;
			}

			return pPacket;
		}

	private:
		size_t m_numReads;
		size_t m_numWrites;
		std::queue<std::pair<ionet::SocketOperationCode, GenerateReadPacket>> m_queuedReads;
		std::queue<ionet::SocketOperationCode> m_queuedWrites;
		std::vector<std::shared_ptr<ionet::Packet>> m_writtenPackets;
	};
}}
